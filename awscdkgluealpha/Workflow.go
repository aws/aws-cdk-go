package awscdkgluealpha

import (
	_init_ "github.com/aws/aws-cdk-go/awscdkgluealpha/v2/jsii"
	_jsii_ "github.com/aws/jsii-runtime-go/runtime"

	"github.com/aws/aws-cdk-go/awscdk/v2"
	"github.com/aws/aws-cdk-go/awscdk/v2/awsglue"
	"github.com/aws/constructs-go/constructs/v10"
)

// This module defines a construct for creating and managing AWS Glue Workflows and Triggers.
//
// AWS Glue Workflows are orchestration services that allow you to create, manage, and monitor complex extract, transform, and load (ETL) activities involving multiple crawlers, jobs, and triggers. Workflows are designed to allow you to manage interdependent jobs and crawlers as a single unit, making it easier to orchestrate and monitor complex ETL pipelines.
//
// Triggers are used to initiate an AWS Glue Workflow. You can configure different types of triggers, such as on-demand, scheduled, event-based, or conditional triggers, to start your Workflow based on specific conditions or events.
//
// Example:
//   // The code below shows an example of how to instantiate this type.
//   // The values are placeholders you should change.
//   import glue_alpha "github.com/aws/aws-cdk-go/awscdkgluealpha"
//
//   workflow := glue_alpha.NewWorkflow(this, jsii.String("MyWorkflow"), &WorkflowProps{
//   	DefaultRunProperties: map[string]*string{
//   		"defaultRunPropertiesKey": jsii.String("defaultRunProperties"),
//   	},
//   	Description: jsii.String("description"),
//   	MaxConcurrentRuns: jsii.Number(123),
//   	WorkflowName: jsii.String("workflowName"),
//   })
//
// See: https://docs.aws.amazon.com/glue/latest/dg/about-triggers.html
//
// ## Usage Example
//
// ```ts
// const app = new App();
// const stack = new Stack(app, 'TestStack');
//
// // Create a Glue Job
// declare const role: iam.IRole;
// declare const script: glue.Code;
// const job = new glue.PySparkStreamingJob(stack, 'ImportedJob', { role, script });
//
// // Create a Glue Workflow
// const workflow = new glue.Workflow(stack, 'TestWorkflow');
//
// // Add an on-demand trigger to the Workflow
// workflow.addOnDemandTrigger('OnDemandTrigger', {
// actions: [{ job: job }],
// });
// ```.
//
// Experimental.
type Workflow interface {
	WorkflowBase
	// The environment this resource belongs to.
	//
	// For resources that are created and managed by the CDK
	// (generally, those created by creating new class instances like Role, Bucket, etc.),
	// this is always the same as the environment of the stack they belong to;
	// however, for imported resources
	// (those obtained from static methods like fromRoleArn, fromBucketName, etc.),
	// that might be different than the stack they were imported into.
	// Experimental.
	Env() *awscdk.ResourceEnvironment
	// The tree node.
	// Experimental.
	Node() constructs.Node
	// Returns a string-encoded token that resolves to the physical name that should be passed to the CloudFormation resource.
	//
	// This value will resolve to one of the following:
	// - a concrete value (e.g. `"my-awesome-bucket"`)
	// - `undefined`, when a name should be generated by CloudFormation
	// - a concrete name generated automatically during synthesis, in
	//   cross-environment scenarios.
	// Experimental.
	PhysicalName() *string
	// The stack in which this resource is defined.
	// Experimental.
	Stack() awscdk.Stack
	// The ARN of the workflow.
	// Experimental.
	WorkflowArn() *string
	// The name of the workflow.
	// Experimental.
	WorkflowName() *string
	// Add a Condition (Predicate) based trigger to the workflow.
	//
	// Returns: The created CfnTrigger resource.
	// Experimental.
	AddConditionalTrigger(id *string, options *ConditionalTriggerOptions) awsglue.CfnTrigger
	// Add a custom-scheduled trigger to the workflow.
	//
	// Returns: The created CfnTrigger resource.
	// Experimental.
	AddCustomScheduledTrigger(id *string, options *CustomScheduledTriggerOptions) awsglue.CfnTrigger
	// Add a daily-scheduled trigger to the workflow.
	//
	// Returns: The created CfnTrigger resource.
	// Experimental.
	AddDailyScheduledTrigger(id *string, options *DailyScheduleTriggerOptions) awsglue.CfnTrigger
	// Add an Event Bridge based trigger to the workflow.
	//
	// Returns: The created CfnTrigger resource.
	// Experimental.
	AddNotifyEventTrigger(id *string, options *NotifyEventTriggerOptions) awsglue.CfnTrigger
	// Add an on-demand trigger to the workflow.
	//
	// Returns: The created CfnTrigger resource.
	// Experimental.
	AddOnDemandTrigger(id *string, options *OnDemandTriggerOptions) awsglue.CfnTrigger
	// Add a weekly-scheduled trigger to the workflow.
	//
	// Returns: The created CfnTrigger resource.
	// Experimental.
	AddWeeklyScheduledTrigger(id *string, options *WeeklyScheduleTriggerOptions) awsglue.CfnTrigger
	// Apply the given removal policy to this resource.
	//
	// The Removal Policy controls what happens to this resource when it stops
	// being managed by CloudFormation, either because you've removed it from the
	// CDK application or because you've made a change that requires the resource
	// to be replaced.
	//
	// The resource can be deleted (`RemovalPolicy.DESTROY`), or left in your AWS
	// account for data recovery and cleanup later (`RemovalPolicy.RETAIN`).
	// Experimental.
	ApplyRemovalPolicy(policy awscdk.RemovalPolicy)
	// Experimental.
	BuildWorkflowArn(scope constructs.Construct, workflowName *string) *string
	// Experimental.
	GeneratePhysicalName() *string
	// Returns an environment-sensitive token that should be used for the resource's "ARN" attribute (e.g. `bucket.bucketArn`).
	//
	// Normally, this token will resolve to `arnAttr`, but if the resource is
	// referenced across environments, `arnComponents` will be used to synthesize
	// a concrete ARN with the resource's physical name. Make sure to reference
	// `this.physicalName` in `arnComponents`.
	// Experimental.
	GetResourceArnAttribute(arnAttr *string, arnComponents *awscdk.ArnComponents) *string
	// Returns an environment-sensitive token that should be used for the resource's "name" attribute (e.g. `bucket.bucketName`).
	//
	// Normally, this token will resolve to `nameAttr`, but if the resource is
	// referenced across environments, it will be resolved to `this.physicalName`,
	// which will be a concrete name.
	// Experimental.
	GetResourceNameAttribute(nameAttr *string) *string
	// Returns a string representation of this construct.
	// Experimental.
	ToString() *string
}

// The jsii proxy struct for Workflow
type jsiiProxy_Workflow struct {
	jsiiProxy_WorkflowBase
}

func (j *jsiiProxy_Workflow) Env() *awscdk.ResourceEnvironment {
	var returns *awscdk.ResourceEnvironment
	_jsii_.Get(
		j,
		"env",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Workflow) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Workflow) PhysicalName() *string {
	var returns *string
	_jsii_.Get(
		j,
		"physicalName",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Workflow) Stack() awscdk.Stack {
	var returns awscdk.Stack
	_jsii_.Get(
		j,
		"stack",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Workflow) WorkflowArn() *string {
	var returns *string
	_jsii_.Get(
		j,
		"workflowArn",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Workflow) WorkflowName() *string {
	var returns *string
	_jsii_.Get(
		j,
		"workflowName",
		&returns,
	)
	return returns
}


// Experimental.
func NewWorkflow(scope constructs.Construct, id *string, props *WorkflowProps) Workflow {
	_init_.Initialize()

	if err := validateNewWorkflowParameters(scope, id, props); err != nil {
		panic(err)
	}
	j := jsiiProxy_Workflow{}

	_jsii_.Create(
		"@aws-cdk/aws-glue-alpha.Workflow",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Experimental.
func NewWorkflow_Override(w Workflow, scope constructs.Construct, id *string, props *WorkflowProps) {
	_init_.Initialize()

	_jsii_.Create(
		"@aws-cdk/aws-glue-alpha.Workflow",
		[]interface{}{scope, id, props},
		w,
	)
}

// Extract workflowName from arn.
// Experimental.
func Workflow_ExtractNameFromArn(scope constructs.Construct, workflowArn *string) *string {
	_init_.Initialize()

	if err := validateWorkflow_ExtractNameFromArnParameters(scope, workflowArn); err != nil {
		panic(err)
	}
	var returns *string

	_jsii_.StaticInvoke(
		"@aws-cdk/aws-glue-alpha.Workflow",
		"extractNameFromArn",
		[]interface{}{scope, workflowArn},
		&returns,
	)

	return returns
}

// Import an workflow from it's name.
// Experimental.
func Workflow_FromWorkflowArn(scope constructs.Construct, id *string, workflowArn *string) IWorkflow {
	_init_.Initialize()

	if err := validateWorkflow_FromWorkflowArnParameters(scope, id, workflowArn); err != nil {
		panic(err)
	}
	var returns IWorkflow

	_jsii_.StaticInvoke(
		"@aws-cdk/aws-glue-alpha.Workflow",
		"fromWorkflowArn",
		[]interface{}{scope, id, workflowArn},
		&returns,
	)

	return returns
}

// Import an existing workflow.
// Experimental.
func Workflow_FromWorkflowAttributes(scope constructs.Construct, id *string, attrs *WorkflowAttributes) IWorkflow {
	_init_.Initialize()

	if err := validateWorkflow_FromWorkflowAttributesParameters(scope, id, attrs); err != nil {
		panic(err)
	}
	var returns IWorkflow

	_jsii_.StaticInvoke(
		"@aws-cdk/aws-glue-alpha.Workflow",
		"fromWorkflowAttributes",
		[]interface{}{scope, id, attrs},
		&returns,
	)

	return returns
}

// Import a workflow from its name.
// Experimental.
func Workflow_FromWorkflowName(scope constructs.Construct, id *string, workflowName *string) IWorkflow {
	_init_.Initialize()

	if err := validateWorkflow_FromWorkflowNameParameters(scope, id, workflowName); err != nil {
		panic(err)
	}
	var returns IWorkflow

	_jsii_.StaticInvoke(
		"@aws-cdk/aws-glue-alpha.Workflow",
		"fromWorkflowName",
		[]interface{}{scope, id, workflowName},
		&returns,
	)

	return returns
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
// Experimental.
func Workflow_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	if err := validateWorkflow_IsConstructParameters(x); err != nil {
		panic(err)
	}
	var returns *bool

	_jsii_.StaticInvoke(
		"@aws-cdk/aws-glue-alpha.Workflow",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Returns true if the construct was created by CDK, and false otherwise.
// Experimental.
func Workflow_IsOwnedResource(construct constructs.IConstruct) *bool {
	_init_.Initialize()

	if err := validateWorkflow_IsOwnedResourceParameters(construct); err != nil {
		panic(err)
	}
	var returns *bool

	_jsii_.StaticInvoke(
		"@aws-cdk/aws-glue-alpha.Workflow",
		"isOwnedResource",
		[]interface{}{construct},
		&returns,
	)

	return returns
}

// Check whether the given construct is a Resource.
// Experimental.
func Workflow_IsResource(construct constructs.IConstruct) *bool {
	_init_.Initialize()

	if err := validateWorkflow_IsResourceParameters(construct); err != nil {
		panic(err)
	}
	var returns *bool

	_jsii_.StaticInvoke(
		"@aws-cdk/aws-glue-alpha.Workflow",
		"isResource",
		[]interface{}{construct},
		&returns,
	)

	return returns
}

func (w *jsiiProxy_Workflow) AddConditionalTrigger(id *string, options *ConditionalTriggerOptions) awsglue.CfnTrigger {
	if err := w.validateAddConditionalTriggerParameters(id, options); err != nil {
		panic(err)
	}
	var returns awsglue.CfnTrigger

	_jsii_.Invoke(
		w,
		"addConditionalTrigger",
		[]interface{}{id, options},
		&returns,
	)

	return returns
}

func (w *jsiiProxy_Workflow) AddCustomScheduledTrigger(id *string, options *CustomScheduledTriggerOptions) awsglue.CfnTrigger {
	if err := w.validateAddCustomScheduledTriggerParameters(id, options); err != nil {
		panic(err)
	}
	var returns awsglue.CfnTrigger

	_jsii_.Invoke(
		w,
		"addCustomScheduledTrigger",
		[]interface{}{id, options},
		&returns,
	)

	return returns
}

func (w *jsiiProxy_Workflow) AddDailyScheduledTrigger(id *string, options *DailyScheduleTriggerOptions) awsglue.CfnTrigger {
	if err := w.validateAddDailyScheduledTriggerParameters(id, options); err != nil {
		panic(err)
	}
	var returns awsglue.CfnTrigger

	_jsii_.Invoke(
		w,
		"addDailyScheduledTrigger",
		[]interface{}{id, options},
		&returns,
	)

	return returns
}

func (w *jsiiProxy_Workflow) AddNotifyEventTrigger(id *string, options *NotifyEventTriggerOptions) awsglue.CfnTrigger {
	if err := w.validateAddNotifyEventTriggerParameters(id, options); err != nil {
		panic(err)
	}
	var returns awsglue.CfnTrigger

	_jsii_.Invoke(
		w,
		"addNotifyEventTrigger",
		[]interface{}{id, options},
		&returns,
	)

	return returns
}

func (w *jsiiProxy_Workflow) AddOnDemandTrigger(id *string, options *OnDemandTriggerOptions) awsglue.CfnTrigger {
	if err := w.validateAddOnDemandTriggerParameters(id, options); err != nil {
		panic(err)
	}
	var returns awsglue.CfnTrigger

	_jsii_.Invoke(
		w,
		"addOnDemandTrigger",
		[]interface{}{id, options},
		&returns,
	)

	return returns
}

func (w *jsiiProxy_Workflow) AddWeeklyScheduledTrigger(id *string, options *WeeklyScheduleTriggerOptions) awsglue.CfnTrigger {
	if err := w.validateAddWeeklyScheduledTriggerParameters(id, options); err != nil {
		panic(err)
	}
	var returns awsglue.CfnTrigger

	_jsii_.Invoke(
		w,
		"addWeeklyScheduledTrigger",
		[]interface{}{id, options},
		&returns,
	)

	return returns
}

func (w *jsiiProxy_Workflow) ApplyRemovalPolicy(policy awscdk.RemovalPolicy) {
	if err := w.validateApplyRemovalPolicyParameters(policy); err != nil {
		panic(err)
	}
	_jsii_.InvokeVoid(
		w,
		"applyRemovalPolicy",
		[]interface{}{policy},
	)
}

func (w *jsiiProxy_Workflow) BuildWorkflowArn(scope constructs.Construct, workflowName *string) *string {
	if err := w.validateBuildWorkflowArnParameters(scope, workflowName); err != nil {
		panic(err)
	}
	var returns *string

	_jsii_.Invoke(
		w,
		"buildWorkflowArn",
		[]interface{}{scope, workflowName},
		&returns,
	)

	return returns
}

func (w *jsiiProxy_Workflow) GeneratePhysicalName() *string {
	var returns *string

	_jsii_.Invoke(
		w,
		"generatePhysicalName",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (w *jsiiProxy_Workflow) GetResourceArnAttribute(arnAttr *string, arnComponents *awscdk.ArnComponents) *string {
	if err := w.validateGetResourceArnAttributeParameters(arnAttr, arnComponents); err != nil {
		panic(err)
	}
	var returns *string

	_jsii_.Invoke(
		w,
		"getResourceArnAttribute",
		[]interface{}{arnAttr, arnComponents},
		&returns,
	)

	return returns
}

func (w *jsiiProxy_Workflow) GetResourceNameAttribute(nameAttr *string) *string {
	if err := w.validateGetResourceNameAttributeParameters(nameAttr); err != nil {
		panic(err)
	}
	var returns *string

	_jsii_.Invoke(
		w,
		"getResourceNameAttribute",
		[]interface{}{nameAttr},
		&returns,
	)

	return returns
}

func (w *jsiiProxy_Workflow) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		w,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

